# be-java-cafe
마스터즈 2023 스프링 카페<br>2차 리뷰 대비 다시 작성

# 1-1. 회원 가입 기능 구현

#### <목표>
- [ㅇ]가입하기 페이지에서 회원 가입 폼을 표시한다(기본 Html에 있음)<br>
- []Html에서 중복된 부분을 분리한다<br>
- []개인정보를 입력하고 확인을 누르면 회원 목록 조회 페이지로 이동한다

#### <설계>
- 폼에 정보 입력하고 확인 클릭을 하면: 입력한 정보가 서버로 전송(스프링 부트는 내장 서버를 가지고 있다)<br>
[@PostMapping]으로 form에서 데이터 전송하는 것 구현(HttpRequest 중 Post메소드: 값을 추가한다.)


- 회원 목록 조회 페이지로 이동:<br> 
==> 그냥 간게 아니고 양식(validation)에 맞게 User(회원) 필드 값을 다 써서 엔터(submit) 누르면....<br>
  로딩 후 회원 목록(회원 관리)페이지 <<<< 로 화면이 바뀐다는 것이 요구사항.
<br>   
※중요!<br>
         로딩 중에 일어나는 일: '서버로 데이터를 보내서 저장'<br>
  (여기서는 회원가입에 대한 거니까 -> '회원정보'데이터가 추가되야 하는 상황이므로)<br>
    1. 회원 객체가 하나 추가되고(회원 정보는 객체로 관리->필드 변수로 회원 정보 저장)<br>
    2. 회원 목록 객체 -> list.html 회원 목록 조회 템플릿 페이지에서 템플릿 엔진 덕에 동적으로 보여질 수 있는 데이터들<br>
        -> 목록에 있는 회원 데이터를 저장+조회+조건검색+뽑아낼 수 있는 데이터베이스(원래는 실제 DB가 할 역할)


- 예상 작업 순서:<br> 
        1. 일단 확인이 되야 하니까 한 2개 쯤 회원 객체가 들어있는 회원 목록 객체 + 그것을 동적으로 보여주는 회원 조회 페이지.<br> 
        2. (수동으로 이동해서 보면 됨) 템플릿 엔진으로 동적 작동이 되는 회원 목록 조회 페이지(list.html)


- 우연히 알게 된 어노테이션들:<br> 
        @Service -> 비지니스 로직(무슨 뜻인지 아직 잘 모름)<br> 
        @Repository -> 저장소<br>
        @AutoWired -> (뭔지 아직 모름)<br>
        @RequestBody -> POST API인데 Json일때 필요


- 기존에 가입했던 회원들 목록이 조회 화면에서 정렬되서 보여져야 될 텐데(자동으로 되는지 아직 모름)<br>
아마도 최근에 가입한 회원이 맨 위에 있으면 될 듯.


- User 자료형 필드변수: 주어진 html을 보면 아이디, 이름, 이메일, +패스워드,(그리고 뭐가 더 필요할지 아직 모름)


#### <학습>
- bean: @Controller, @Service, @Repository 등이 붙으면 bean이다(@Component)
- @AutoWired: 생성자에 사용(@Service)
- @Service: Service 클래스(@Component)
- Service 클래스 하는 역할: 
- Model: .addAttribute로 컨트롤러에서 데이터를 받아서 view(mustache)에 전달(ui 구성 역할)
- redirect: F5

회원가입 기능으로 form에서 보낸 데이터를 @PostMapping으로 받을 때, 처리를 @Service(+@repository)로 하는 부분에 대해서 
사실 로직만 맞으면 되는 것 같은 생각에 Service 클래스나 repository 클래스를 굳이 만들지 않아도 되는 것이 아닌지 많이 궁금했습니다.
(repository의 메소드의 호출을 그냥 repository를 호출해서 하는게 아니라 Service에 repository를 import한 후 repository 메소드를 Service하는 것이 이해가 안 된 부분의 예입니다 -> '????'하다고 느꼈습니다)
(그리고 그래서 실제로 없이 한번 해볼까 하기도 했습니다만 -> Service + repository 또는 Controller + Service + repository 등..)
물론 OOP 자체가 이해도 잘 되고 보기도 좋으라고 객체를 나누듯이 Service와 repository를 나눈 것이라고 보면 되는 부분이긴 한데요(저는 왜 이런 것만 보면 자꾸 심술이 나는 것 같은지 모르겠습니다.....)

일단 이번에는 그렇게 하지 않은 이유는 어노테이션으로 매우 분명하게 나눠져 있는 걸로 보여 한계로 느꼈기 때문인데요,
그런데 혹시 그래도 @Servie나 @repository 어노테이션을 꼭 써야 하는 것 같지만 -> @Component가 있으므로 혹시 원래는 클래스 구성도 제 맘대로 Service나 repository라는 이름도 제 맘대로 할 수 있는 부분이지 않았을지는 지금도 궁금합니다.
(대세를 따르기 위해서 그러면 안 된다는 것 외에 다른 이유가 또 있을 수 있을지 궁금합니다~~)
/
제가 아직 잘 몰라서 그런 것인지 모르겠습니다만, 
DTO인 'UserForm'객체를 'User'객체로 (굳이(구태여)) 변환하는 과정을 거치거나 하는 부분에 대해서도 이해하기 어려웠습니다. 
그냥 처음부터 User가 받게 하면 될 것 같이 보였기 때문입니다. 그래서 저는 이번에 그렇게 했습니다(User가 DTO로 그냥 form에서 받고 회원 객체이고 repository에 저장도 됩니다)
혹시 DTO(form에서 일단 받는 역할)이 나중에 repository에 저장될 실제 회원 객체하고 역할이 분리가 되야만 하는 무슨 이유가 있는 것인지 궁금합니다(제가 학습을 안 해서 모르는 것이 아닌지 혹시나 불안감이....)
/
@RequestMapping이 뭔지 알 것 같은데 반드시 필요한 것인지 아닌지 아직 알지 못해서 그냥 안 썼습니다. 
하지만 혹시 역시 사용하는 것이 좋다고 보시는지 궁금합니다. 그래서 깨우쳐 주시면 감사하겠습니다.
/
@repository 저장소를 인터페이스로 구현되는 부분에 대해서 왜 이것이 인터페이스로 구현될 필요가 있는지 전혀 모르고 있어서 궁금해하고 있습니다.(사실 인터페이스 자체를 잘 몰라서일지도 모릅니다 ㅎㅎㅎ;;)
그러니까 같은 이름과 개념을 돌려쓸 수 있는 것 같지만 아직 코드가 많지 않아서 그런지 꼭 이렇게까지 정리를 해야 하는지 잘 모르겠다는 느낌입니다(나중에 실무에선 꼭 이렇게 할 테니 그래도 매우 좋다고 보시는지 궁금합니다)
또한 특히 repository이기 때문에 이런 것이 필요한지도 매우 궁금합니다.
/
@repository에 있는 List<User> 같은 필드 변수를 저는 왠지 (제가 잘 몰라서 그럴 것 같은데요 ㅎㅎㅎㅎㅎㅎ)
그냥 필드에서 'List<User> = new List' 처럼 그냥 필드 속성에서 new로 하면 될 것 같은데 생성자를 이용해서 생성할 때 만들도록(당연히 그래도 될 텐데 결과적으로 같지 않은가 하여)
반드시 저렇게 방법으로 해야 하는 이유가 혹시 특별히 있지 않을지 궁금합니다.(그래서 이번에는 그렇게 해보았습니다 ㅎㅎㅎㅎㅎ)
